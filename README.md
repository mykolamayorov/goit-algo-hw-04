# Порівняння алгоритмів сортування: Merge Sort, Insertion Sort та Timsort

## Мета
Порівняти алгоритми сортування за часом виконання, підтвердити теоретичні оцінки складності емпіричними даними та продемонструвати переваги Timsort.

## Алгоритми

- **Insertion Sort** – простий, ефективний для малих масивів (O(n²))
- **Merge Sort** – стабільний, гарантує O(n log n)
- **Timsort** – гібрид merge sort та insertion sort, використовується у Python `sorted`/`.sort()`

## Методика

Для заміру часу виконання використано `timeit`. Дані генерувались випадково у масивах розміром 100, 1000, 5000, 10000, 20000. Для великих масивів Insertion Sort не тестувався через низьку ефективність.

## Результати (фрагмент)

| Size | MergeSort (с) | InsertionSort (с) | Timsort (с) |
|------|----------------|-------------------|-------------|
| 100  | 0.0004         | 0.0002            | 0.0001      |
| 1000 | 0.006          | 0.12              | 0.001       |
| 5000 | 0.03           | N/A               | 0.005       |
| 10000| 0.08           | N/A               | 0.01        |

## Висновки

- Insertion Sort ефективний лише для дуже малих масивів.
- Merge Sort показує стабільну ефективність незалежно від структури даних.
- Timsort найшвидший у всіх випадках, завдяки поєднанню двох підходів:
  - Використання Insertion Sort для малих підмасивів (run).
  - Використання Merge Sort для злиття відсортованих блоків.

## Чому використовують Timsort?
Timsort забезпечує найкращу ефективність на практиці, особливо на частково відсортованих або структурованих даних. Саме тому вбудовані функції Python `sorted()` та `.sort()` використовують саме Timsort.